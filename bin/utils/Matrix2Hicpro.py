#!/usr/bin/env python

# Matrix2Hicpro.py
# Copyleft 2015 Institut Curie
# Author(s): Nelle Varoquaux, Nicolas Servant
# Contact: nicolas.servant@curie.fr
# This software is distributed without any guarantee under the terms of the
# GNU General
# Public License, either Version 2, June 1991 or Version 3, June 2007.

"""
Script to transfer triplet interactors matrixs to spase matrix same as hicpro
"""

import argparse
import os
import sys
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import re as re
import array
from collections import defaultdict
plt.rcParams['pdf.fonttype'] = 42


from mpl_toolkits.axes_grid1 import make_axes_locatable

## 
def heatmap_plot(ax, M):
    plt.sca(ax)
    colorscale=""
    if useviridis:
        if hasattr(plt.cm, 'viridis'):
            colorscale=plt.cm.viridis
        else:
            print ("\nUsing 'old' Matplotlib - doesn't support new fancy color scheme 'viridis' \nReverting to older color scheme afmhot_r")
            colorscale=plt.cm.afmhot_r
    else:
        print ("\nUsing 'traditional' color scheme afmhot_r")
        colorscale=plt.cm.afmhot_r
    
    # plot
    lm = ax.imshow(M, interpolation='nearest', extent=[0, 10, 0, 10],
                   origin='upper',vmin = 0, vmax = 10, cmap=colorscale, clip_on=True)
  
    # set x label
    label_plot = str(chromid) + ":" + str(start) + "-" + str(stop) + "-" + str(binsize) + "bp"   
    plt.xlabel(label_plot, fontsize = 8)
    
    # scale figure 
    fig.set_size_inches(3, 3)	
    
    # set title
    title = "3C-HTGTS_Tri \nInput file : " + matrixfile + "\n"
    heading = plt.title(title, loc='center', fontsize = 8)    
    
    plt.tight_layout()
    
    # ticks,tick labels,figure frame
    ax.set_yticklabels([])
    ax.set_xticklabels([])
    ax.set_frame_on(False)
    ax.set_yticks([])
    ax.set_xticks([])
    
    # plot color bar to scale with the plot, not with the whole page
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="2%", pad=0.10)
    plt.colorbar(lm, cax=cax)
    
#    font = {'family' : 'serif',
#            'weight' : 'normal',
#            'size'   : '0.1',
#           }
#    cb.set_label('colorbar',fontdict=font)


## defination : BS:binsize of interaction
def Bin_Bed(chromsizefile, binsize, chromid):
    # read chrom size file
    infile = open(chromsizefile)
    binsize = binsize
    chr_id = chromid
    chsDict = {}
    CHS = infile.read().strip()
    for Iterm in CHS.split("\n"):
        Index = Iterm.split("\t")[0]
        Value = Iterm.split("\t")[1]
        chsDict[Index] = Value
    #bin bed file
    binList = []
    end = int(chsDict[chromid])
#    nfile = open(matrixfile)
    start = 0
    ID = 1
    while start+binsize <= end :
        binList.append([chromid, str(start), str(start + binsize), str(ID)])
        start += binsize
        ID += 1
    binList.append([chromid, str(start), str(end), str(ID)])    
    return binList



## function for sparse matrix
def Bin_Mat(matrixfile, binsize):
#    infile = open(chromsizefile)
#    binsize = binsize
#    chr_id = chromid
#    chsDict = {}
#    CHS = infile.read().strip()
#    for Iterm in CHS.split("\n"):
#        Index = Iterm.split("\t")[0]
#        Value = Iterm.split("\t")[1]
#        chsDict[Index] = Value

#    end = int(chsDict[chromid])
    
    # creat matrix
#    w_bins = end + 1
#    wholematrix = np.zeros((w_bins, w_bins))

#    bin_start = start / binsize
#    bin_stop = stop / binsize
#    l_bins = int(bin_stop - bin_start)
#    localmatrix = np.zeros((l_bins, l_bins))
    # read matrix file
    infile = open(matrixfile)
    binsize = binsize

    # count interation
    totalcount = 0
    matrixDict = {}
    RFrag_dict = defaultdict(list)
    
    MAT = infile.read().strip()
    for Iterm in MAT.split("\n"):
#        chrnum = Iterm.split("\t")[1].split("|")[0].split("_")[2]
	
        # starting coordinate of two restriction fragments except bait
        first_s = Iterm.split("\t")[1].split("|")[1].split(":")[1].split("-")[0]
        second_s = Iterm.split("\t")[2].split("|")[1].split(":")[1].split("-")[0]
	# end coordinate of two restriction fragments except bait
        first_e = Iterm.split("\t")[1].split("|")[1].split("-")[1]
        second_e = Iterm.split("\t")[2].split("|")[1].split("-")[1]
	
	# midpoint of two restriction fragments except bait
        mid1 = (int(first_s) + int(first_e)) / 2
        mid2 = (int(second_s) + int(second_e)) / 2
	
        # first less than second generated by continuse filter
        if mid1 >= start and mid1 < stop and mid2 >= start and mid2 < stop and int(first_e) <= int(second_e):
            Index = str(int(first_e) // binsize + 1) + "_" + str(int(second_e) // binsize + 1)
            bin1 = int(first_e) // binsize + 1
            bin2 = int(second_e) // binsize + 1
            if mid1 not in RFrag_dict[bin1]:
                RFrag_dict[bin1].append(mid1)
#                print(RFrag_dict)
            if mid2 not in RFrag_dict[bin2]:
                RFrag_dict[bin2].append(mid2)
#                print(RFrag_dict)
#        else:
#            Index = str(int(second_e) // binsize + 1) + "_" + str(int(first_e) // binsize + 1)
            if Index in matrixDict:
                matrixDict[Index] += 1
            else:
                matrixDict[Index] = 1
    for k in matrixDict.keys():
        totalcount += matrixDict[k]

	
    # matrix out list : first binId, second_binId, numbers
    rawmatrixList = []
    normatrixList = []
    totalmatrixList = []
    for k, v in matrixDict.items():
        fid = k.split("_")[0]
        sid = k.split("_")[1]
        bin1 = int(fid)
        bin2 = int(sid)
        s = fid + "\t" + sid + "\t" + str(v) + "\n"
        S = len(RFrag_dict[bin1]) * len(RFrag_dict[bin2])
        normcount = 1.0*int(v) / S  * 1000000 / int(totalcount)
        n = fid + "\t" + sid + "\t" + str(normcount) + "\n"
        rawmatrixList.append(s)
        normatrixList.append(n)
        
        if int(fid) >= int(bin_start) and int(fid) < int(bin_stop) and int(sid) >= int(bin_start) and int(sid) < int(bin_stop):
            localmatrix[int(fid) - bin_start, int(sid) - bin_stop] += normcount
#            wholematrix[int(fid), int(sid)] += normcount
    totalmatrixList.append(rawmatrixList)
    totalmatrixList.append(normatrixList)
    totalmatrixList.append(localmatrix)
    return totalmatrixList
    return localmatrix




## main function
if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-m','--matrixfile',
                       dest = 'matrix')
    parser.add_argument('-i','--chromsome_id',
                       dest = 'chromid')
    parser.add_argument('-b','--binsize',
                       dest = 'binsize')
    parser.add_argument('-c', '--chromsome_size',
                        dest = 'chromsize')
    parser.add_argument('-o', '--output_dir',
                        dest = 'outdir')
    parser.add_argument('-a', '--start',
                        dest = 'start')
    parser.add_argument('-p', '--stop',
                        dest = 'stop')
#    parser.add_argument('-v', '--viridis',
#                        dest = 'True')
#    parser.add_argument('-a', '--afmhot',
#                        dest = 'False')

    args = parser.parse_args()
    matrixfile = args.matrix
    chromid = args.chromid
    binsize = int(args.binsize)
    chromsizefile = str(args.chromsize)
    outdir = str(args.outdir)
    start = int(args.start)
    stop = int(args.stop)

useviridis = True
#    useviridis = args.False


BinBed = Bin_Bed(chromsizefile, binsize, chromid)
bin_start = int(start / binsize)
bin_stop = int(stop / binsize)
l_bins = int(bin_stop - bin_start)
localmatrix = np.zeros((l_bins, l_bins))
BinMat = Bin_Mat(matrixfile, binsize)

## make the subplot object(s) and fig object to call later
fig, ax = plt.subplots(1,1)

## plot localheatmap
heatmap_plot(ax, localmatrix)


# write out Bin_Bed and Bin_Mat
ref = os.path.basename(chromsizefile).split(".")[0]
fnam = os.path.basename(matrixfile).split(".")[0]
binbed_name = "%s_%s_%i.bed" %(ref, chromid, binsize)
rawoutmatrix_name = "%s_%i.raw.matrix" %(fnam, binsize)
normoutmatrix_name = "%s_%i.norm.matrix" %(fnam, binsize)
fig_path=os.path.dirname(os.path.dirname(outdir))

## save plot
plt.savefig(fig_path + "/" + fnam + "_" + str(chromid) + "_" + str(binsize) + ".pdf",format='pdf', dpi=1000)

b_fo = open(outdir + "/" + binbed_name, "w")
rm_fo = open(outdir + "/" + rawoutmatrix_name, "w")
nm_fo = open(outdir + "/" + normoutmatrix_name, "w")


for L in BinBed:
    s = '\t'.join(L)
    b_fo.write( s + "\n" )


for LI in BinMat[0]:
    rm_fo.write( LI )
for LI in BinMat[1]:
    nm_fo.write( LI )

# save local array(localmatrix is array)
np.savetxt(outdir + "/" + fnam + "_" + str(chromid) + "_" + str(binsize) + "_" + 'array.txt', BinMat[2],fmt="%.2f", delimiter='\t')

rm_fo.close()
nm_fo.close()
